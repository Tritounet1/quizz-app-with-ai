<template>
  <div id="app" class="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 py-8">
    <div v-if="!isFinish" class="max-w-4xl mx-auto px-6">
      <!-- En-t√™te avec num√©ro de question -->
      <div class="text-center mb-8">
        <span
          class="inline-block bg-indigo-600 text-white px-4 py-2 rounded-full font-semibold text-sm"
        >
          Question {{ questions[currentQuestionIndex].id }} / {{ questions.length }}
        </span>
      </div>

      <!-- Question principale -->
      <div class="bg-white rounded-xl shadow-lg p-8 mb-6">
        <h2 class="text-2xl md:text-3xl font-bold text-gray-800 text-center leading-relaxed">
          {{ questions[currentQuestionIndex].question }}
        </h2>
      </div>

      <!-- Options de r√©ponse -->
      <div class="space-y-4">
        <div
          v-for="(option, index) in questions[currentQuestionIndex].options"
          :key="index"
          @click="nextQuestion(index)"
          class="bg-white rounded-lg shadow-md hover:shadow-lg transition-shadow duration-200 cursor-pointer border-2 border-transparent hover:border-indigo-300"
        >
          <div class="p-6 flex items-center space-x-4">
            <div
              class="flex-shrink-0 w-8 h-8 bg-indigo-100 rounded-full flex items-center justify-center"
            >
              <span class="text-indigo-600 font-semibold">{{
                String.fromCharCode(65 + index)
              }}</span>
            </div>
            <p class="text-gray-700 text-lg flex-1">{{ option }}</p>
          </div>
        </div>
      </div>
    </div>
    <!-- Page de r√©sultats -->
    <div v-else class="max-w-4xl mx-auto px-6">
      <div class="text-center">
        <!-- Ic√¥ne de fin -->
        <div class="mb-8">
          <div v-if="getScorePercentage >= 80" class="text-6xl">üéâ</div>
          <div v-else-if="getScorePercentage >= 60" class="text-6xl">üëç</div>
          <div v-else class="text-6xl">üìö</div>
        </div>

        <!-- Titre -->
        <h1 class="text-4xl md:text-5xl font-bold text-gray-800 mb-4">Quiz termin√© !</h1>

        <!-- Score principal -->
        <div class="bg-white rounded-xl shadow-lg p-8 mb-8">
          <div class="text-6xl font-bold mb-4" :class="getScoreColor">
            {{ goodResponse }} / {{ questions.length }}
          </div>
          <div class="text-2xl text-gray-600 mb-2">{{ getScorePercentage }}% de r√©ussite</div>
          <div class="text-lg" :class="getScoreTextColor">
            {{ getScoreMessage }}
          </div>
        </div>

        <!-- D√©tails des r√©sultats -->
        <div class="grid md:grid-cols-3 gap-6 mb-8">
          <div class="bg-green-50 border-2 border-green-200 rounded-lg p-6">
            <div class="text-green-600 text-3xl font-bold">{{ goodResponse }}</div>
            <div class="text-green-700 font-medium">Bonnes r√©ponses</div>
          </div>
          <div class="bg-red-50 border-2 border-red-200 rounded-lg p-6">
            <div class="text-red-600 text-3xl font-bold">{{ questions.length - goodResponse }}</div>
            <div class="text-red-700 font-medium">Erreurs</div>
          </div>
          <div class="bg-blue-50 border-2 border-blue-200 rounded-lg p-6">
            <div class="text-blue-600 text-3xl font-bold">{{ getScorePercentage }}%</div>
            <div class="text-blue-700 font-medium">Pourcentage</div>
          </div>
        </div>

        <!-- Boutons d'action -->
        <div class="space-y-4">
          <button
            @click="restartQuiz"
            class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-8 rounded-lg transition-colors duration-200 shadow-lg hover:shadow-xl"
          >
            üîÑ Recommencer le quiz
          </button>
        </div>
      </div>
    </div>
  </div>
</template>

<script lang="ts">
export default {
  name: 'App',
  data() {
    return {
      goodResponse: 0,
      currentQuestionIndex: 0,
      isFinish: false,
      questions: [
        {
          id: 1,
          question: "Qu'est-ce que l'overfitting en machine learning ?",
          options: [
            "Le mod√®le m√©morise les donn√©es d'entra√Ænement mais performe mal sur de nouvelles donn√©es",
            'Le mod√®le est trop simple',
            "Le mod√®le n'a pas assez de donn√©es",
            "Le mod√®le s'entra√Æne trop vite",
          ],
          correct: 0,
          explication:
            "L'overfitting (surajustement) se produit quand un mod√®le apprend trop sp√©cifiquement les donn√©es d'entra√Ænement, incluant le bruit, ce qui r√©duit sa capacit√© √† g√©n√©raliser sur de nouvelles donn√©es.",
        },
        {
          id: 2,
          question:
            "Quelle est la diff√©rence principale entre l'apprentissage supervis√© et non supervis√© ?",
          options: [
            "Le type d'algorithme utilis√©",
            "La vitesse d'entra√Ænement",
            "La pr√©sence ou absence de labels dans les donn√©es d'entra√Ænement",
            'Le nombre de features utilis√©es',
          ],
          correct: 2,
          explication:
            "L'apprentissage supervis√© utilise des donn√©es √©tiquet√©es (avec des r√©ponses connues) pour apprendre, tandis que l'apprentissage non supervis√© trouve des patterns dans des donn√©es sans √©tiquettes.",
        },
        {
          id: 3,
          question: 'Que mesure la pr√©cision (precision) en classification ?',
          options: [
            "L'erreur moyenne du mod√®le",
            'Le pourcentage de pr√©dictions correctes sur toutes les pr√©dictions',
            'Parmi les vrais positifs, combien ont √©t√© correctement identifi√©s',
            'Parmi les pr√©dictions positives, combien sont vraiment positives',
          ],
          correct: 3,
          explication:
            "La pr√©cision = TP/(TP+FP). Elle indique, parmi toutes les pr√©dictions positives du mod√®le, quelle proportion est r√©ellement positive. Elle r√©pond √† 'Quand je dis oui, ai-je raison ?'",
        },
        {
          id: 4,
          question: '√Ä quoi sert la validation crois√©e (cross-validation) ?',
          options: [
            '√Ä r√©duire le nombre de features',
            '√Ä √©valuer la performance du mod√®le de mani√®re plus robuste',
            '√Ä augmenter la taille du dataset',
            "√Ä acc√©l√©rer l'entra√Ænement",
          ],
          correct: 1,
          explication:
            'La validation crois√©e divise les donn√©es en plusieurs plis (folds) pour entra√Æner et tester le mod√®le plusieurs fois, donnant une estimation plus fiable de ses performances.',
        },
        {
          id: 5,
          question: "Qu'est-ce qu'un r√©seau de neurones convolutif (CNN) ?",
          options: [
            'Un r√©seau qui utilise uniquement des connexions r√©currentes',
            'Un r√©seau qui ne peut traiter que du texte',
            "Un r√©seau sp√©cialis√© dans le traitement d'images",
            'Un r√©seau sans couches cach√©es',
          ],
          correct: 2,
          explication:
            'Les CNNs utilisent des couches convolutives qui appliquent des filtres sur les images pour d√©tecter des features locales (contours, formes). Ils sont particuli√®rement efficaces pour la vision par ordinateur.',
        },
        {
          id: 6,
          question: "Que fait l'algorithme de gradient descent ?",
          options: [
            'Il g√©n√®re de nouvelles donn√©es',
            'Il classe les donn√©es en groupes',
            'Il s√©lectionne les meilleures features',
            'Il optimise les param√®tres du mod√®le en minimisant la fonction de co√ªt',
          ],
          correct: 3,
          explication:
            'Le gradient descent ajuste it√©rativement les param√®tres du mod√®le dans la direction oppos√©e au gradient pour minimiser la fonction de perte et am√©liorer les performances.',
        },
        {
          id: 7,
          question: "Qu'est-ce que le clustering en machine learning ?",
          options: [
            'Une technique de r√©duction de dimensionnalit√©',
            "Un moyen d'augmenter la taille du dataset",
            'Une m√©thode pour regrouper des donn√©es similaires sans labels',
            'Une technique de classification supervis√©e',
          ],
          correct: 2,
          explication:
            "Le clustering (K-means, DBSCAN, etc.) est une technique d'apprentissage non supervis√© qui groupe automatiquement les donn√©es en clusters bas√©s sur leur similitude.",
        },
        {
          id: 8,
          question: 'Que mesure le score F1 ?',
          options: [
            'La moyenne harmonique entre pr√©cision et rappel',
            "Le nombre d'erreurs du mod√®le",
            'La complexit√© computationnelle',
            "La vitesse d'ex√©cution du mod√®le",
          ],
          correct: 0,
          explication:
            'Le score F1 = 2 √ó (pr√©cision √ó rappel)/(pr√©cision + rappel). Il combine pr√©cision et rappel en une seule m√©trique, utile quand on veut √©quilibrer les deux.',
        },
        {
          id: 9,
          question: "Qu'est-ce que la r√©gularisation en machine learning ?",
          options: [
            'Une technique de visualisation',
            "Une m√©thode pour pr√©venir l'overfitting en ajoutant une p√©nalit√© aux param√®tres complexes",
            'Un moyen de nettoyer les donn√©es',
            "Une technique pour acc√©l√©rer l'entra√Ænement",
          ],
          correct: 1,
          explication:
            "La r√©gularisation (L1, L2, dropout) ajoute une p√©nalit√© au mod√®le pour limiter sa complexit√© et r√©duire l'overfitting. Elle force le mod√®le √† rester plus simple et g√©n√©ralisable.",
        },
        {
          id: 10,
          question: 'Quelle est la diff√©rence entre un param√®tre et un hyperparam√®tre ?',
          options: [
            'Les hyperparam√®tres sont plus importants',
            "Il n'y a pas de diff√©rence",
            'Les param√®tres ne changent jamais',
            'Les param√®tres sont appris automatiquement, les hyperparam√®tres sont d√©finis manuellement',
          ],
          correct: 3,
          explication:
            "Les param√®tres (poids, biais) sont appris automatiquement pendant l'entra√Ænement. Les hyperparam√®tres (learning rate, nombre d'epochs, architecture) sont d√©finis avant l'entra√Ænement et contr√¥lent le processus d'apprentissage.",
        },
      ],
    }
  },
  computed: {
    getScorePercentage() {
      return Math.round((this.goodResponse / this.questions.length) * 100)
    },
    getScoreColor() {
      const percentage = this.getScorePercentage
      if (percentage >= 80) return 'text-green-600'
      if (percentage >= 60) return 'text-yellow-600'
      return 'text-red-600'
    },
    getScoreTextColor() {
      const percentage = this.getScorePercentage
      if (percentage >= 80) return 'text-green-700'
      if (percentage >= 60) return 'text-yellow-700'
      return 'text-red-700'
    },
    getScoreMessage() {
      const percentage = this.getScorePercentage
      if (percentage >= 90) return 'Excellent ! Vous ma√Ætrisez parfaitement le sujet ! üåü'
      if (percentage >= 80) return 'Tr√®s bien ! Vous avez une bonne compr√©hension ! üëè'
      if (percentage >= 70) return 'Bien jou√© ! Quelques r√©visions et ce sera parfait ! üìà'
      if (percentage >= 60) return 'Pas mal ! Continuez √† √©tudier pour vous am√©liorer ! üí™'
      if (percentage >= 50) return 'Il faut r√©viser un peu plus ! Courage ! üìñ'
      return 'Ne vous d√©couragez pas, la pratique m√®ne √† la perfection ! üéØ'
    },
  },
  methods: {
    nextQuestion(index: number) {
      console.log('Option s√©lectionn√©e:', index)
      if (index === this.questions[this.currentQuestionIndex].correct) {
        this.goodResponse++
      }
      if (this.currentQuestionIndex < this.questions.length - 1) {
        this.currentQuestionIndex++
      } else {
        this.isFinish = true
      }
    },
    restartQuiz() {
      this.currentQuestionIndex = 0
      this.goodResponse = 0
      this.isFinish = false
    },
    async generateQuestions(topic: string, difficulty: string, numberOfQuestions: number) {
      const response = await fetch('http://localhost:3001/api/generate-questions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          topic: topic,
          difficulty: difficulty,
          numberOfQuestions: numberOfQuestions,
        }),
      })

      const data = await response.json()
      return data.questions
    },
  },
}
</script>
